rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isNotDeactivated() {
      let userData = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
      return !('deactivated' in userData) || userData.deactivated != true;
    }

    function isMember() {
      return isAuthenticated() && isNotDeactivated() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['MEMBER', 'ADMIN', 'SUPERADMIN']);
    }
    
    function isSuperAdmin() {
      return isMember() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['SUPERADMIN']);
    }
    
    function isAdmin() {
      return isMember() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny(['SUPERADMIN', 'ADMIN']);
    }
    
    function isBootswart(boatId) {
      return isMember() &&
        (boatId == "" || boatId == null ||
        get(/databases/$(database)/documents/boats/$(boatId)).data.bootswart == request.auth.uid);
    }
    
    function isAllowedDomain() {
      return request.auth != null && 
             request.auth.token.email != null && 
             request.auth.token.email.matches('.*@mitglied\\.segelgruppe-kiel\\.de$');
    }
    
    function hasSufficientWorkHours(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId)).data;
      
      // If skipHours is enabled, always return true
      if (userDoc.skipHours == true) {
        return true;
      }
      
      // Get system config for work hour threshold and year change date
      let config = get(/databases/$(database)/documents/systemConfig/default).data;
      let thresholdHours = config.workHourThreshold;
      
      // Calculate the current year's change date
      let yearChangeDate = config.yearChangeDate;
      let currentYear = request.time.year;
      let currentDate = request.time;
      
      // Create date objects for comparison
      let thisYearChangeDate = timestamp(
        year=currentYear, 
        month=yearChangeDate.month + 1, // months are 0-11 in JS
        day=yearChangeDate.day, 
        hour=0, 
        minute=0, 
        second=0
      );
      
      // Determine the effective change date (current or previous year)
      let effectiveChangeDate = thisYearChangeDate;
      if (currentDate < thisYearChangeDate) {
        // If current date is before this year's change date, use last year's
        effectiveChangeDate = timestamp(
          year=currentYear - 1, 
          month=yearChangeDate.month + 1, 
          day=yearChangeDate.day, 
          hour=0, 
          minute=0, 
          second=0
        );
      }
      
      // Get all work appointments since the effective change date where user is a confirmed participant
      let workAppointments = get(
        get(/databases/$(database)/documents/workAppointments)
          .where('endTime', '>=', effectiveChangeDate)
          .where('participants', 'array-contains', {
            userId: userId,
            status: 'confirmed'
          })
      ).docs.map(doc => doc.data());
      
      // Calculate total work hours in milliseconds
      let totalWorkMs = 0;
      for (let i = 0; i < workAppointments.size(); i++) {
        let appt = workAppointments[i];
        let participant = appt.participants.find(p => p.userId == userId);
        
        // Use participant's times if available, otherwise use appointment times
        let start = participant && participant.startTime ? 
                   participant.startTime : appt.startTime;
        let end = participant && participant.endTime ? 
                 participant.endTime : appt.endTime;
                 
        // Add duration in milliseconds
        totalWorkMs += end.seconds * 1000 + end.nanoseconds / 1000000 - 
                      (start.seconds * 1000 + start.nanoseconds / 1000000);
      }
      
      // Convert threshold to milliseconds (hours * 3600 * 1000)
      let thresholdMs = thresholdHours * 3600 * 1000;
      
      return totalWorkMs >= thresholdMs;
    }

    // User collection rules
    match /users/{userId} {
      // Allow users to read their own document
      allow read: if (request.auth != null && request.auth.uid == userId) || isMember();

      // Allow members to list all users
      allow list: if isMember();
      
      // Allow creation for:
      // 1. Admins
      // 2. Users with allowed domain (auto-approve as MEMBER)
      // 3. Self-registration as APPLICANT
      allow create: if isAdmin() || 
        (request.auth.uid == userId && (
          // Auto-approve if from allowed domain
          (isAllowedDomain() && 
           request.resource.data.keys().hasAll(['email', 'displayName', 'roles']) &&
           request.resource.data.roles.hasOnly(['MEMBER']) &&
           request.resource.data.email.matches('.*@mitglied\\.segelgruppe-kiel\\.de$')) ||
          // Standard applicant registration
          (request.resource.data.keys().hasAll(['email', 'displayName', 'roles']) &&
           request.resource.data.roles.hasOnly(['APPLICANT']))
        ));
      
      // Users can update their own basic info, admins can update most things, superadmins can update everything
      allow update: if 
        // Users can update their own basic info (except email)
        (request.auth.uid == userId && 
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['displayName', 'lastLoginAt']) &&
         request.resource.data.email == resource.data.email) || 
        // Admins can update everything except superadmin role
        (isAdmin() && 
         (!request.resource.data.roles.hasAny(['SUPERADMIN']) || 
          (resource.data.roles.hasAny(['SUPERADMIN']) && request.resource.data.roles.hasAny(['SUPERADMIN'])))) || 
        // Only superadmins can grant/revoke superadmin role
        isSuperAdmin();
      
      // Only admins can delete users
      allow delete: if isAdmin();
    }

    // Boat collection rules
    match /boats/{boatId} {
      allow read: if isMember();
      allow create, delete: if isAdmin();
      allow update: if isAdmin() || isBootswart(boatId);
    }

    // Boat reservation rules
    match /boatReservations/{reservationId} {
      allow read: if isMember();
      allow create: if isMember() &&
        // Only allow creation if user is eligible (fees paid and work hours completed or hours skipped)
        (isAdmin() || 
        (request.resource.data.userId == request.auth.uid &&
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.feesPaid == true &&
         (hasSufficientWorkHours(request.auth.uid) || 
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.skipHours == true)));
          
      // Only allow updates that don't change the user ID
      allow update: if 
        (isAdmin() || 
        (isMember() && 
         resource.data.userId == request.auth.uid &&
         (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId']) || 
          request.resource.data.userId == resource.data.userId)));
          
      allow delete: if isAdmin() || 
        (isMember() && resource.data.userId == request.auth.uid);
    }

    // Work hours rules
    match /workHours/{docId} {
      allow read: if isMember();
      allow create: if isMember() &&
        (request.resource.data.userId == request.auth.uid || isAdmin());
      allow update, delete: if isMember() &&
        (resource.data.userId == request.auth.uid || isAdmin());
    }

    // Work appointment rules
    match /workAppointments/{appointmentId} {
      allow read: if isMember();
      
      // Only admins and bootswarts can create appointments
      allow create: if isAdmin() || isBootswart(request.resource.data.boatId) ||
      (
        isMember()
        && request.resource.data.private
        && request.resource.data.participants.size() == 1
        && request.resource.data.participants[0].userId == request.auth.uid
      );
      
      // Members can update ONLY the participants array for themselves
      allow update: if 
        // Admins and bootswarts can update everything
        isAdmin() || isBootswart(request.resource.data.boatId) ||
        // Members can only update participants array and only for themselves
        (isMember() && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['participants']) &&
        (
          // Either adding or removing or updating exactly one participant
          (
            // Case 1: Adding themselves
            (request.resource.data.participants.removeAll(resource.data.participants).size() == 1 && 
             resource.data.participants.removeAll(request.resource.data.participants).size() == 0 &&
             request.resource.data.participants.removeAll(resource.data.participants)[0].userId == request.auth.uid) ||
            // Case 2: Removing themselves (only when status is pending)
            (resource.data.participants.removeAll(request.resource.data.participants).size() == 1 && 
             request.resource.data.participants.removeAll(resource.data.participants).size() == 0 &&
             resource.data.participants.removeAll(request.resource.data.participants)[0].userId == request.auth.uid &&
             request.resource.data.participants.removeAll(resource.data.participants)[0].status == "pending") ||
            // Case 3: Updating their own status
            (request.resource.data.participants.removeAll(resource.data.participants).size() == 1 && 
             resource.data.participants.removeAll(request.resource.data.participants).size() == 1 &&
             request.resource.data.participants.removeAll(resource.data.participants)[0].userId == request.auth.uid &&
             resource.data.participants.removeAll(request.resource.data.participants)[0].userId == request.auth.uid &&
             resource.data.participants.removeAll(request.resource.data.participants)[0].status == "pending")
          )
        ));
      
      // Only admins and bootswarts can delete appointments
      allow delete: if isAdmin() || isBootswart(request.resource.data.boatId);
    }

    // System config rules
    match /systemConfig/default {
      allow read: if isAuthenticated();
      allow write: if isSuperAdmin();
    }
  }
}
